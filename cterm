#!/usr/bin/env python3
"""ClusterTerminal (`cterm`) forwards all keystrokes from a master window to
multiple slave windows. Use `cterm` as a method for performing ad hoc tasks,
not as a substitute for automation frameworks.

Todo:
    * Simplify the Master class; some of its functionality should be moved out,
        possibly to the Screen class.
"""

import os
import re
import socket
import sys
import termios
import threading
from math import ceil
from shlex import quote, split
from time import sleep

BIN_LOCATION = quote(os.path.abspath(sys.argv[0]))
MASTER_BASE_TITLE = 'ClusterTerminal Master â€“ '
MASTER_COLOR = '84,30,22'
MASTER_HEIGHT_MAX = 200
MASTER_HEIGHT_MIN = 45
MENU_CHAR = 19  # CTRL+S. Value from 1 to 26, corresponding to the alphabet.
SLAVE_COLOR = '0,0,0'
SLAVE_DISABLED_COLOR = '30,30,30'
SLAVE_SELECTED_SHIFT = '0,0,60'
SOCKET_ALIVE_INTERVAL = 0.5  # How often to check for open sockets
SOCKET_TIMEOUT = 0.0001  # Used to check if socket is still alive
TERMINAL = None  # Search for the bundle identifier once and set it here


class Master:
    """The brain of the operation where the orchestration happens."""

    def __init__(self, args, base_command):
        # Asumption: Launcher checked screen ID before creating master window
        height = min(max(MASTER_HEIGHT_MIN, args.mw_h), MASTER_HEIGHT_MAX)
        self.args = args
        self.base_command = base_command
        self.columns = None  # Generate using the aspect ratio
        self.pause = args.pause
        self.rows = None  # Match with columns' time of calculation
        self.screen = Screen(height, args.screen)
        self.selected = None
        self.slaves = []
        self.socket = socket_create()
        self.window_id = get_window_id(os.ttyname(sys.stdout.fileno()))

        self.create_slaves(args.item)
        self.socket_connected_check()  # Start the socket check

        menu = Menu(self.send)
        menu.add_bind(self.add_items, 'a', '[a]dd items')
        menu.add_bind(self.enable_windows, 'e', '[e]nable')
        menu.add_bind(self.sort_slaves, 'o', 's[o]rt')
        menu.add_bind(self.arrange_windows, 'r', '[r]earrage')
        menu.add_bind(self.change_screen, 's', 'change [s]creen')
        menu.add_bind(self.send_text, 't', 'send [t]ext')
        menu.add_bind(self.column_decrease, '<', '[<|>] change column count',
                      True)
        menu.add_bind(self.column_increase, '>', remain=True)
        menu.add_bind(self.exit, 'x', 'e[x]it')
        menu.add_bind(self.send_text, 't', 'send [t]ext')
        menu.listen()

    def create_slaves(self, items):
        """Create slaves and arrange windows afterwards."""
        for item in items:
            self.slaves.append(
                Slave(self.args, self.base_command, item, self.socket))

            if items[-1] != item:  # Inter-window pause, but not on last window
                sleep(self.pause / 1000)
        self.arrange_windows()

    def remove_slave(self, slaves):
        """Remove slave (or list of slaves) from master"""
        try:
            if not isinstance(slaves, list):
                slaves = [slaves]
            for slave in slaves:
                self.slaves.remove(slave)
        except ValueError:
            pass
        self.update_title()

    def send(self, string):
        """Send a string to all slaves (disabled ones will ignore it)."""
        for slave in self.slaves:
            try:
                slave.send(string)
            except Exception:
                self.remove_slave(slave)

    def socket_connected_check(self):
        """Check whether all connections to the socket as still active. Remove
        the slaves with a dead connection."""

        def check():
            while True:
                dead_slaves = []
                for slave in self.slaves:
                    try:
                        slave.conn.recv(1)
                    except socket.timeout:
                        continue  # Timed-out; someone is still there!
                    dead_slaves.append(slave)

                if self.slaves == dead_slaves:  # Everyone's dead
                    os._exit(0)

                self.remove_slave(dead_slaves)  # Remove dead slaves
                sleep(SOCKET_ALIVE_INTERVAL)

        threading.Thread(target=check).start()

    def find_slave(self, location):
        """Find a slave according to its location on the window grid."""
        for slave in self.slaves:
            if slave.window_position.location == location:
                return slave
        return None

    def refresh_selection(self):
        """Confirm that the currently selected slave window exists. Otherwise,
        pick first slave. Return whether the current selection changed."""
        if self.selected is None or self.find_slave(
                self.selected.window_position.location) is None:
            self.selected = self.slaves[0]
            return True
        return False

    def update_layout(self, new_column_count):
        """Update the column count, and subsequently the row count."""
        self.columns = max(1, min(len(self.slaves), new_column_count))
        self.rows = ceil(len(self.slaves) / self.columns)

    def update_title(self):
        """Update the title according the current list of slaves."""
        title = MASTER_BASE_TITLE + ' '.join([x.item for x in self.slaves])
        os.system('printf \'\\e]0;%s\\a\' \'{}\';'.format(title))

    def add_items(self):
        """Add additional items (slaves)."""
        items = prompt('Items')

        if items.strip() != '':
            self.create_slaves(split(items))  # shelx.split to get list of args
        self.update_title()

    def arrange_windows(self):
        """Arrange the windows on the grid according the current column count.
        Remove any slaves without active windows IDs."""
        self.remove_slave(  # Remove slaves with unknown windows; likely closed
            [x for x in self.slaves if get_window(x.window_id) is None])

        if self.columns is None:
            self.columns = self.screen.get_columns_default(len(self.slaves))
        positions = self.screen.get_positions(len(self.slaves), self.columns)
        self.update_layout(self.columns)

        for slave, position in zip(self.slaves, positions[1:]):
            slave.window_position = position
            slave.window_position.move_window(get_window(slave.window_id))
        positions[0].move_window(get_window(self.window_id))  # Master window
        self.refresh_selection()

    def change_screen(self):
        """Call upon the Screen instance to change the screen used. If changed,
        rearrange the windows."""
        if self.screen.change_screen():
            self.arrange_windows()

    def column_decrease(self):
        """Decrease the column count of the grid of windows."""
        current = self.columns
        self.update_layout(self.columns - 1)
        if current != self.columns:  # Layout changed
            self.arrange_windows()

    def column_increase(self):
        """Increase the column count of the grid of windows."""
        current = self.columns
        self.update_layout(self.columns + 1)
        if current != self.columns:  # Layout changed
            self.arrange_windows()

    def enable_windows(self):
        """Menu for managing which windows are enabled."""

        def update_selection(pos_x, pos_y):
            if self.refresh_selection():
                return  # Selection changed; leave

            for i in range(1, max(self.rows, self.columns) + 1):
                pos_x = self.selected.window_position.location[0] + pos_x * i
                pos_y = self.selected.window_position.location[1] + pos_y * i

                # Prevent out of bounds
                pos_x = max(min(self.columns - 1, pos_x), 0)
                pos_y = max(min(self.rows - 1, pos_y), 0)

                slave = self.find_slave([pos_x, pos_y])
                if slave is not None:
                    self.selected.update_state(selected=False)
                    self.selected = slave
                    self.selected.update_state(selected=True)
                    break

        self.refresh_selection()
        self.selected.update_state(selected=True)  # Highlight selected

        def disable_odd():
            for slave in self.slaves[1::2]:
                slave.update_state(enabled=False)

        def enable_all():
            for slave in self.slaves:
                slave.update_state(enabled=True)

        def toggle_all():
            for slave in self.slaves:
                slave.update_state(enabled=not slave.enabled)

        def toggle_selected():
            self.selected.update_state(enabled=not self.selected.enabled)

        def move_up():
            update_selection(0, -1)

        def move_down():
            update_selection(0, 1)

        def move_left():
            update_selection(-1, 0)

        def move_right():
            update_selection(1, 0)

        menu = Menu()
        menu.add_bind(move_up, 'w', '[WASD] move selection', True)
        menu.add_bind(move_down, 's', remain=True)
        menu.add_bind(move_left, 'a', remain=True)
        menu.add_bind(move_right, 'd', remain=True)
        menu.add_bind(toggle_selected, ' ', '[space] toggle selection', True)
        menu.add_bind(disable_odd, 'o', 'disable every [o]ther', True)
        menu.add_bind(enable_all, 'n', 'e[n]able all', True)
        menu.add_bind(toggle_all, 't', '[t]oggle enabled', True)
        menu.main()

        self.selected.update_state(selected=False)  # Unhighlight selected

    def exit(self):
        """Exit the program."""
        self.slaves = []  # Empty array to signal end for socket check thread
        cprint()
        sys.exit()

    def send_text(self):
        """Send relative text to each slave."""

        def send_id():
            for slave in self.slaves:
                slave.send(str(slave.sid))

        def send_item():
            for slave in self.slaves:
                slave.send(str(slave.item))

        menu = Menu()
        menu.add_bind(send_id, 'i', '[i]d')
        menu.add_bind(send_item, 't', 'i[t]em')
        menu.main()

    def sort_slaves(self):
        """Sort the slave windows."""

        def by_id():
            self.slaves = sorted(self.slaves, key=lambda x: x.sid)
            self.arrange_windows()

        def by_natural():
            self.slaves = sorted(self.slaves, key=sort_natural_key)
            self.arrange_windows()

        menu = Menu()
        menu.add_bind(by_id, 'i', '[i]d')
        menu.add_bind(by_natural, 'n', '[n]atural')
        menu.main()


class Slave:
    """Spawns a Slave window for the master to command."""
    ID = 0  # Per-instance ID; increments during __init__

    def __init__(self, args, base_command, item, sock):
        Slave.ID += 1
        command = quote(item) + ' --mode slave --socket ' + sock.getsockname()

        self.bg_disabled = get_color(args.sw_c_d, SLAVE_DISABLED_COLOR)
        self.bg_normal = get_color(args.sw_c, SLAVE_COLOR)
        self.bg_shift = get_color(args.selected, SLAVE_SELECTED_SHIFT)
        self.enabled = True
        self.item = item
        self.selected = False
        self.sid = Slave.ID
        self.tab = open_terminal(base_command.format(item, command))
        self.window_id = get_window_id(self.tab.tty())
        self.window_position = None

        self.conn, _ = sock.accept()
        self.conn.settimeout(SOCKET_TIMEOUT)  # For checking if socket is alive

        # The text color is set to white in case it's someting else
        self.tab.setNormalTextColor_(get_color('255,255,255'))
        self.update_state()  # Update color

    def send(self, string):
        """Send `string` to the slave's window."""
        if self.enabled:
            for char in string:
                self.conn.send(str.encode(char))

    def update_state(self, enabled=None, selected=None):
        """update the state of the slave and, accordingly, its window color."""
        if enabled is not None:
            self.enabled = enabled
        if selected is not None:
            self.selected = selected

        if self.selected:
            shift_r = self.bg_shift.redComponent()
            shift_g = self.bg_shift.greenComponent()
            shift_b = self.bg_shift.blueComponent()
        else:
            shift_r = shift_g = shift_b = 0

        color = self.bg_normal if self.enabled else self.bg_disabled
        color = get_color('{},{},{}'.format(
            int((color.redComponent() + shift_r) * 255),
            int((color.greenComponent() + shift_g) * 255),
            int((color.blueComponent() + shift_b) * 255)))

        self.tab.setBackgroundColor_(color)


class Menu:
    """A menuing system that uses a list of "binds" for navigation."""
    init_tc_attr = None  # The initial attributes of the terminal

    def __init__(self, send=None):
        self.binds = []
        self.send = send

        if Menu.init_tc_attr is None:
            Menu.init_tc_attr = tc_get()

    def add_bind(self, action, key, msg=None, remain=False):
        """Add a bind to the menu which calls `action` when `key` is hit and
        returns after being hit if `remain`. `msg`, if not None, is used in the
        menu's text."""
        self.binds.append({
            'action': action,
            'key': ord(key.lower()),
            'msg': msg,
            'remain': remain
        })

    def listen(self):
        """Indefinitely listen to key strokes. If the menu character is hit,
        enter the menu. Otherwise, the character is supplied to `self.send`."""
        listen_msg = '[CTRL+{}] enter menu'.format(chr(MENU_CHAR + 64))

        try:
            tc_raw()
            cprint(listen_msg)

            while True:
                char = sys.stdin.read(1)

                if ord(char) == MENU_CHAR:
                    self.main()
                    cprint(listen_msg)
                elif self.send is not None:
                    self.send(char)
        finally:
            tc_set(Menu.init_tc_attr)

    def main(self):
        """Enters the menu. Exits with ESC."""
        msg = ', '.join(['[ESC] cancel'] +
                        [x['msg'] for x in self.binds if x['msg'] is not None])
        cprint(msg)

        while True:
            char = sys.stdin.read(1)

            if ord(char) == 27:  # ESC
                return
            if ord(char) == MENU_CHAR:  # Send menu character if hit twice
                if self.send is not None:
                    self.send(char)
                return

            for bind in self.binds:
                if ord(char.lower()) == bind['key']:
                    bind['action']()  # Run action of Bind
                    if not bind['remain']:  # Bind didn't ask to stay
                        return


class Screen:
    """Represent a screen and its bounds"""

    def __init__(self, master_height, screen_id):
        self.master_height = master_height
        self.update_bounds(get_screen_bounds(get_screen(screen_id)))

    def change_screen(self):
        """Change the current screen, taking into account the new bounds. If
        screen changed, return True. Otherwise, return False."""
        screen = prompt(get_screen(reinit=True))
        if screen.isdigit() and int(screen) > 0:
            screen = get_screen(int(screen), reinit=True)
            if screen.startswith('_'):  # Valid response; got coordinates
                self.update_bounds(get_screen_bounds(screen))
                return True  # Changed successfully
        return False

    def get_columns_default(self, count, columns=1):
        """Get a column count that would generate windows that closely reflect
        the aspect ratio of the screen. Leave `columns as 1`."""
        width, height = self.width, self.u_height
        size = self.get_window_size(count, columns)
        ratio = size[1] / size[0]

        if ratio > height / width:
            return {columns: ratio}

        ratios = {
            columns: ratio,
            **self.get_columns_default(count, columns + 1)
        }

        key, value = min(ratios.items(),
                         key=lambda x: abs(x[1] - height / width))

        return key if columns == 1 else {key: value}

    def get_positions(self, count, columns):
        """Generate a list of WindowPositions according to the window count and
        number of requested columns."""
        rows = ceil(count / columns)
        size = self.get_window_size(count, columns)

        master_window = WindowPosition([], [self.origin_x, self.origin_y],
                                       [self.width, self.master_height])
        positions = [master_window]  # First window position is the master

        for row in reversed(range(rows)):  # Reversed(bottom to top)
            for column in range(columns):  # Left to right
                position = [
                    self.origin_x + (column * size[0]),
                    self.origin_y + self.master_height + (row * size[1])
                ]  # The y origin is flipped (0 is bottom, not top
                location = [column, abs(rows - row - 1)]
                positions.append(WindowPosition(location, position, size))

        return positions

    def get_window_size(self, count, columns):
        """Return the size ([width, height]) for a window based on the number
        of windows (count) and the column count (columns)."""
        return [self.width / columns, self.u_height / ceil(count / columns)]

    def update_bounds(self, bounds):
        """Use the output of `get_screen_bounds` to update screen bounds."""
        self.origin_x = bounds[0]
        self.origin_y = bounds[1]
        self.width = bounds[2]
        self.height = bounds[3]
        self.u_height = bounds[3] - self.master_height


class WindowPosition:
    """Represents the location on the grid of windows, origin relative to the
    screen, and window size."""

    def __init__(self, location, origin, size):
        self.location = location
        self.origin = origin
        self.size = size

    def move_window(self, window):
        """Move a Terminal `window` to the bounds defined by current instance.

        When resized or moved, macOS honors the screen bounds at the current
        origin and won't resize past bounds. This means that if the window was
        resized or moved but exceeded the bounds, the window will not have the
        desired size. To get around this, Resize the window first, relocate
        (definitely not out of bounds due to first resize), then resize again
        (initial resize might've hit bounds). Can't use `setBounds_` as it
        honors the window's minimum bounds."""
        window.setVisible_(0)  # Pop tab if in a multi-tab window
        window.setSize_(self.size)
        window.setOrigin_(self.origin)
        window.setSize_(self.size)  # Don't worry; still really quick
        window.setFrontmost_(1)  # Above other windows


def args_init():
    """Initialzes arguments and returns the output of `parse_args`"""
    import argparse

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('command',
                        type=str,
                        help='the command to run on each item. Can include' +
                        ' arguments if quoted')
    parser.add_argument('item',
                        type=str,
                        nargs='+',
                        help='one or more items, each passed as a positional' +
                        ' argument to an instance of the command')
    parser.add_argument('-k',
                        '--keep',
                        action='store_true',
                        help='keep windows even after command exits cleanly')
    parser.add_argument('-p',
                        '--pause',
                        type=int,
                        metavar='ms',
                        help='milliseconds to wait between each window',
                        default=0)
    parser.add_argument('-s',
                        '--screen',
                        type=int,
                        metavar='id',
                        help='screen number to display windows on',
                        default=1)
    parser.add_argument('--selected',
                        type=str,
                        metavar='r,g,b',
                        help='color shift when window is selected',
                        default=SLAVE_SELECTED_SHIFT)
    parser.add_argument('--mw-c',
                        type=str,
                        metavar='r,g,b',
                        help='color of the master window',
                        default=MASTER_COLOR)
    parser.add_argument('--mw-h',
                        type=int,
                        metavar='px',
                        help='height of the master window',
                        default=MASTER_HEIGHT_MIN)
    parser.add_argument('--sw-c',
                        type=str,
                        metavar='r,g,b',
                        help='color of a slave window',
                        default=SLAVE_COLOR)
    parser.add_argument('--sw-c-d',
                        type=str,
                        metavar='r,g,b',
                        help='color of a disabled slave window',
                        default=SLAVE_DISABLED_COLOR)

    # Hidden arguments relating to program internals
    parser.add_argument('--mode', type=str, help=argparse.SUPPRESS)
    parser.add_argument('--socket', type=str, help=argparse.SUPPRESS)
    parser.add_argument('--reinit',
                        action='store_true',
                        help=argparse.SUPPRESS)

    return parser.parse_args()


def cprint(string=None):
    """Clear screen and print `string` if supplied."""
    os.system('clear && printf \'\\e[3J\'')
    if string is not None:
        print(string, end='', flush=True)


def get_base_command(args, title='{}'):
    """Returns a string containing the command to be used as a format string.

    Parameters:
        args (argparse.Namespace): The arguments returns from `args_init`.
        title (str): The terminal title to set. Defaults to `{}` to be used in
            the format string.
    """
    carried = ['history -d $(($HISTCMD-1));']  # Remove from history
    carried.append('clear && printf \'\\e[3J\';')  # Clear screen
    carried.append('printf \'\\e]0;%s\\a\' \'{}\';'.format(title))  # Set title
    if not args.keep:  # Close on clean exit
        carried.append('if')
    carried.append(BIN_LOCATION)  # cterm location
    carried += ['--pause', str(args.pause)]
    carried += ['--screen', str(args.screen)]
    carried += ['--selected', str(args.selected)]
    carried += ['--mw-h', str(args.mw_h)]
    carried += ['--sw-c', str(args.sw_c)]
    carried += ['--sw-c-d', str(args.sw_c_d)]
    if args.keep:
        carried.append('--keep')
    carried.append(quote(args.command))  # Escape command to run
    carried.append('{}')  # Used for the items
    if not args.keep:  # Close on clean exit
        carried.append('; then exit; fi')
    return ' '.join(carried)


def get_color(*args):
    """Returns an instance of NSColor. The input is one or more strings in the
    format of `r,g,b`, with each color as an 8-bit color (0 to 255)."""
    for color in args:
        match = re.match(r'(\d+),(\d+),(\d+)', color)
        if match:
            from ScriptingBridge import NSColor
            return NSColor.colorWithDeviceRed_green_blue_alpha_(
                int(match.group(1)) / 255,
                int(match.group(2)) / 255,
                int(match.group(3)) / 255, 0)
    return None


def get_screen(screen_number=0, reinit=False):
    """Return the details of a screen as a string. If the string starts with _
    then the screen was found and should be parsed with `get_screen_bounds`.
    Otherwise, the error message is returned.

    Parameters:
        screen_number (int): screen number to get the details of. If 0, the
            available list is returned.
        reinit (bool): If True, a new process is spawned to get the details.
            This is necessary as a process caches the screen info.
    """
    if reinit:  # Get uncached screen info using a new Window Server connection
        import subprocess
        command = BIN_LOCATION + ' 0 0 --reinit --screen ' + str(screen_number)
        result = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
        return result.stdout.decode().strip()

    from ScriptingBridge import NSApplication, NSBundle, NSScreen

    # Hide the Python launcher icon
    NSBundle.mainBundle().infoDictionary()['LSBackgroundOnly'] = '1'

    # Connect to the Window Server and run initializing code.
    NSApplication.sharedApplication()

    screens = NSScreen.screens()
    count = screens.count()
    available = 'Available screens: ' + ', '.join(
        [str(x) for x in range(1, count + 1)])

    if screen_number == 0:  # Asking for list of screen ID's
        return available
    if screen_number > count:  # Out of bounds
        return 'Screen does not exist. ' + available

    frame = screens.objectAtIndex_(screen_number - 1).visibleFrame()
    return '_' + ','.join([
        str(x) for x in
        [frame.origin.x, frame.origin.y, frame.size.width, frame.size.height]
    ])


def get_screen_bounds(details):
    """Parses the valid output (starts with _) of get_screen and returns the
    origin points and dimentions in a list."""
    return [float(x) for x in details[1:].split(',')]


def get_terminal():
    """Returns the SBApplication for the Terminal bundle"""
    from ScriptingBridge import SBApplication
    global TERMINAL
    if TERMINAL is None:
        bundle = 'com.apple.Terminal'
        TERMINAL = SBApplication.applicationWithBundleIdentifier_(bundle)
        if TERMINAL is None:
            sys.exit('Did not find {}'.format(bundle))
    return TERMINAL


def get_window(window_id):
    """Return the window object with `window_id` or None if not found."""
    return get_terminal().windows().objectWithID_(window_id)


def get_window_id(tty):
    """Return a terminal's window ID by searching using its tty name. Return
    None if not found."""
    for window in get_terminal().windows():
        if tty == window.tabs().objectAtIndex_(0).tty():
            return window.id()
    return None


def open_terminal(command):
    """Open and return a new terminal, running `command`."""
    return get_terminal().doScript_in_(command, 0)


def prompt(question, default=''):
    """Ask `question` and return `input` or `default` when cancelled."""
    current_tc_attr = tc_get()  # Save current
    if Menu.init_tc_attr:  # Restore initial
        tc_set(Menu.init_tc_attr)
    cprint(str(question) + ': ')

    try:
        return input() or default
    except (KeyboardInterrupt, EOFError):
        return default
    finally:  # Restore previous terminal settings
        tc_set(current_tc_attr)


def socket_connect(location):
    """Connect to Unix socket at `location` and mirror key strokes."""

    def tap(sock):
        import fcntl
        try:
            while True:
                data = sock.recv(1024).decode()

                if data == '':  # Got back no data; socket errored out
                    break  # Stop reading from the socket.

                for char in data:
                    fcntl.ioctl(sys.stdin, termios.TIOCSTI, char)
        except Exception:
            pass

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(location)

    threading.Thread(target=tap, args=(sock, )).start()
    return sock


def socket_create():
    """Returns a Unix socket, created using a temporary file."""
    from tempfile import _get_candidate_names, _get_default_tempdir

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(_get_default_tempdir() + '/' + next(_get_candidate_names()))
    sock.listen()
    return sock


def sort_natural_key(_s, _r=re.compile(r'(\d+)')):
    """Natural sorting key (number-aware)."""
    return [int(t) if t.isdigit() else t.lower() for t in _r.split(_s.item)]


def tc_get():
    """Return list of current terminal attributes."""
    return termios.tcgetattr(sys.stdin.fileno())


def tc_raw():
    """Set terminal to raw mode."""
    import tty
    tty.setraw(sys.stdin.fileno())


def tc_set(settings):
    """Set attributes of stdin to settings (list of tty attributes)."""
    termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, settings)


def main():
    """Main entry point"""
    args = args_init()

    if args.reinit:  # Someone requested screen info
        print(get_screen(args.screen))
    elif args.mode is None:  # Spawn master window after some init code
        screen = get_screen(args.screen)
        if not screen.startswith('_'):  # An error message
            sys.exit(screen)

        command = ' '.join([quote(x) for x in args.item]) + ' --mode master'
        title = MASTER_BASE_TITLE + ' '.join(args.item)

        term = open_terminal(get_base_command(args, title).format(command))
        term.setBackgroundColor_(get_color(args.mw_c, MASTER_COLOR))
        term.setNormalTextColor_(get_color('255,255,255'))
    elif args.mode == 'master':  # Master window: spawns and controls slaves
        Master(args, get_base_command(args))
    elif args.mode == 'slave':  # Slave window: runs command and reads input
        sock = socket_connect(args.socket)  # Start mirror keystrokes
        os.system(quote(args.command) + ' ' + quote(args.item[0]))
        sock.close()  # Close socket


if __name__ == '__main__':
    sys.exit(main())
