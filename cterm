#!/usr/bin/env python3

import os
import re
import socket
import sys
import termios
import threading
from math import ceil
from shlex import quote, split
from time import sleep

BIN_LOCATION = quote(os.path.abspath(sys.argv[0]))
MASTER_BASE_TITLE = 'ClusterTerminal Master â€“ '
MASTER_COLOR = '84,30,22'
MASTER_HEIGHT_MAX = 200
MASTER_HEIGHT_MIN = 45
MENU_CHAR = 19  # CTRL+S. Value from 1 to 26, corresponding to the alphabet.
SLAVE_COLOR = '0,0,0'
SLAVE_DISABLED_COLOR = '30,30,30'
SLAVE_SELECTED_BLUE_SHIFT = 40
SOCKET_ALIVE_INTERVAL = 0.5  # How often to check for open sockets
SOCKET_TIMEOUT = 0.0001  # Used to check if socket is still alive
TERMINAL = None  # Search for the bundle identifier once and set it here


class Master:
    def __init__(self, args, base_command):
        # Asumption: Launcher checked screen ID before creating master window
        height = min(max(MASTER_HEIGHT_MIN, args.mw_h), MASTER_HEIGHT_MAX)
        self.base_command = base_command
        self.columns = None  # Generate using the aspect ratio
        self.menu = Menu(self.send)
        self.pause = args.pause
        self.rows = None  # Match with columns' time of calculation
        self.screen = Screen(height, args.screen)
        self.selected = None
        self.slave_bg_disabled = get_color(args.sw_c_d, SLAVE_DISABLED_COLOR)
        self.slave_bg_normal = get_color(args.sw_c, SLAVE_COLOR)
        self.slaves = []
        self.socket = socket_create()
        self.window_id = get_window_id(os.ttyname(sys.stdout.fileno()))

        self.create_slaves(args.item)
        self.socket_connected_check()  # Start the socket check

        # Add binds to menu
        for bind in [
                Bind(self.add_items, 'a', '[a]dd items'),
                Bind(self.enable_windows, 'e', '[e]nable'),
                Bind(self.sort_slaves, 'o', 's[o]rt'),
                Bind(self.arrange_windows, 'r', '[r]earrage'),
                Bind(self.change_screen, 's', 'change [s]creen'),
                Bind(self.send_text, 't', 'send [t]ext'),
                Bind(self.column_decrease, '<', '[<|>] change column count',
                     True),
                Bind(self.column_increase, '>', remain=True),
                Bind(self.exit, 'x', 'e[x]it'),
        ]:
            self.menu.binds.append(bind)
        self.menu.listen()

    def create_slaves(self, items):
        for item in items:
            self.slaves.append(
                Slave(self.base_command, self.slave_bg_normal,
                      self.slave_bg_disabled, item, self.socket))
            # Inter-window pause, but don't pause after last window
            if items[-1] != item: sleep(self.pause / 1000)
        self.arrange_windows()

    def find_slave(self, location):
        for slave in self.slaves:
            if slave.window_position.location == location: return slave

    def refresh_selection(self):
        # Confirm current selection exists. If not, pick first slave
        if self.selected is None or self.find_slave(
                self.selected.window_position.location) is None:
            self.selected = self.slaves[0]
            return True  # Changed

    def remove_slave(self, slaves):
        try:
            if not isinstance(slaves, list): slaves = [slaves]
            for slave in slaves:
                self.slaves.remove(slave)
        except ValueError:
            pass
        self.update_title()

    def send(self, string):
        for slave in self.slaves:
            try:
                slave.send(string)
            except Exception:
                self.remove_slave(slave)

    def socket_connected_check(self):
        def check():
            while True:
                dead_slaves = []
                for slave in self.slaves:
                    try:
                        slave.conn.recv(1)
                    except socket.timeout:
                        continue  # Timed-out; someone is still there!
                    dead_slaves.append(slave)
                if self.slaves == dead_slaves: os._exit(0)  # Everyone's dead
                self.remove_slave(dead_slaves)  # Remove dead slaves
                sleep(SOCKET_ALIVE_INTERVAL)

        threading.Thread(target=check).start()

    def update_layout(self, new_column_count):
        self.columns = max(1, min(len(self.slaves), new_column_count))
        self.rows = ceil(len(self.slaves) / self.columns)

    def update_title(self):
        title = MASTER_BASE_TITLE + ' '.join([x.item for x in self.slaves])
        os.system('printf \'\\e]0;%s\\a\' \'{}\';'.format(title))

    def add_items(self):
        items = prompt('Items')
        # shelx.split to get array of arguments
        if items.strip() != '': self.create_slaves(split(items))
        self.update_title()

    def arrange_windows(self):
        self.remove_slave(  # Remove slaves with unknown windows; likely closed
            [x for x in self.slaves if get_window(x.window_id) is None])

        if self.columns is None:
            self.columns = get_columns_default(self.screen, len(self.slaves))
        positions = get_positions(self.screen, self.columns, len(self.slaves))
        self.update_layout(self.columns)

        for slave, position in zip(self.slaves, positions[1:]):
            slave.window_position = position
            slave.window_position.move_window(get_window(slave.window_id))
        positions[0].move_window(get_window(self.window_id))  # Master window
        self.refresh_selection()

    def change_screen(self):
        if self.screen.change_screen():  # Screen changed
            self.arrange_windows()

    def column_decrease(self):
        current = self.columns
        self.update_layout(self.columns - 1)
        if current != self.columns: self.arrange_windows()

    def column_increase(self):
        current = self.columns
        self.update_layout(self.columns + 1)
        if current != self.columns: self.arrange_windows()

    def enable_windows(self):
        def update_selection(x, y):
            if self.refresh_selection(): return  # Selection changed; leave

            for i in range(1, max(self.rows, self.columns) + 1):
                new_x = self.selected.window_position.location[0] + x * i
                new_y = self.selected.window_position.location[1] + y * i

                # Prevent out of bounds
                new_x = max(min(self.columns - 1, new_x), 0)
                new_y = max(min(self.rows - 1, new_y), 0)

                slave = self.find_slave([new_x, new_y])
                if slave is not None:
                    self.selected.update_state(selected=False)
                    self.selected = slave
                    self.selected.update_state(selected=True)
                    break

        self.refresh_selection()
        self.selected.update_state(selected=True)  # Highlight selected

        def disable_odd():
            for slave in self.slaves[1::2]:
                slave.update_state(enabled=False)

        def enable_all():
            for slave in self.slaves:
                slave.update_state(enabled=True)

        def toggle_all():
            for slave in self.slaves:
                slave.update_state(enabled=not slave.enabled)

        def toggle_selected():
            self.selected.update_state(enabled=not self.selected.enabled)

        def move_up():
            update_selection(0, -1)

        def move_down():
            update_selection(0, 1)

        def move_left():
            update_selection(-1, 0)

        def move_right():
            update_selection(1, 0)

        menu = Menu()
        for bind in [
                Bind(move_up, 'w', '[WASD] move selection', True),
                Bind(move_down, 's', remain=True),
                Bind(move_left, 'a', remain=True),
                Bind(move_right, 'd', remain=True),
                Bind(toggle_selected, ' ', '[space] toggle selection', True),
                Bind(disable_odd, 'o', 'disable every [o]ther', True),
                Bind(enable_all, 'n', 'e[n]able all', True),
                Bind(toggle_all, 't', '[t]oggle enabled', True),
        ]:
            menu.binds.append(bind)
        menu.main()

        self.selected.update_state(selected=False)  # Unhighlight selected

    def exit(self):
        self.slaves = []  # Empty array to signal end for socket check thread
        cprint()
        sys.exit()

    def send_text(self):
        def send_id():
            for slave in self.slaves:
                slave.send(str(slave.sid))

        def send_item():
            for slave in self.slaves:
                slave.send(str(slave.item))

        menu = Menu()
        menu.binds.append(Bind(send_id, 'i', '[i]d'))
        menu.binds.append(Bind(send_item, 't', 'i[t]em'))
        menu.main()

    def sort_slaves(self):
        def by_id():
            self.slaves = sorted(self.slaves, key=lambda x: x.sid)
            self.arrange_windows()

        def by_natural():
            self.slaves = sorted(self.slaves, key=sort_natural_key)
            self.arrange_windows()

        menu = Menu()
        menu.binds.append(Bind(by_id, 'i', '[i]d'))
        menu.binds.append(Bind(by_natural, 'n', '[n]atural'))
        menu.main()


class Slave:
    ID = 0  # Per-instance ID; increments during __init__

    def __init__(self, base_command, bg_normal, bg_disabled, item, sock):
        Slave.ID += 1
        command = quote(item) + ' --mode slave --socket ' + sock.getsockname()

        self.bg_disabled = bg_disabled
        self.bg_normal = bg_normal
        self.enabled = True
        self.item = item
        self.selected = False
        self.sid = Slave.ID
        self.tab = open_terminal(base_command.format(item, command))
        self.window_id = get_window_id(self.tab.tty())
        self.window_position = None

        self.conn, _ = sock.accept()
        self.conn.settimeout(SOCKET_TIMEOUT)  # For checking if socket is alive

        # The text color is set to white in case it's someting else
        self.tab.setNormalTextColor_(get_color('255,255,255'))
        self.update_state()  # Update color

    def send(self, string):
        if self.enabled:
            for char in string:
                self.conn.send(str.encode(char))

    def update_state(self, enabled=None, selected=None):
        if enabled is not None: self.enabled = enabled
        if selected is not None: self.selected = selected

        blue_shift = SLAVE_SELECTED_BLUE_SHIFT if self.selected else 0
        color = self.bg_normal if self.enabled else self.bg_disabled
        color = get_color('{},{},{}'.format(
            int(color.redComponent() * 255), int(color.greenComponent() * 255),
            int(color.blueComponent() * 255 + blue_shift)))

        self.tab.setBackgroundColor_(color)


class Bind:
    def __init__(self, action, key, msg=None, remain=False):
        self.action = action
        self.key = ord(key.lower())
        self.msg = msg
        self.remain = remain


class Menu:
    init_tc_attr = None

    def __init__(self, send=None):
        self.binds = []
        self.send = send

        if Menu.init_tc_attr is None: Menu.init_tc_attr = tc_get()

    def listen(self):
        listen_msg = '[CTRL+{}] enter menu'.format(chr(MENU_CHAR + 64))

        try:
            tc_raw()
            cprint(listen_msg)

            while True:
                char = sys.stdin.read(1)

                if ord(char) == MENU_CHAR:
                    self.main()
                    cprint(listen_msg)
                elif self.send is not None:
                    self.send(char)
        finally:
            tc_set(Menu.init_tc_attr)

    def main(self):
        msg = ', '.join(['[ESC] cancel'] +
                        [x.msg for x in self.binds if x.msg is not None])
        cprint(msg)  # Print msg for menu

        while True:
            char = sys.stdin.read(1)

            if ord(char) == 27: break  # ESC
            if ord(char) == MENU_CHAR:  # Send menu character if hit twice
                if self.send is not None: self.send(char)
                return

            for bind in self.binds:
                if ord(char.lower()) == bind.key:
                    bind.action()  # Run action of Bind
                    if not bind.remain: return  # Bind didn't ask to stay


class Screen:
    def __init__(self, master_height, screen_id):
        self.master_height = master_height
        self.update_bounds(get_screen_bounds(get_screen(screen_id)))

    def change_screen(self):
        screen = prompt(get_screen(reinit=True))
        if screen.isdigit() and int(screen) > 0:
            screen = get_screen(int(screen), reinit=True)
            if screen.startswith('_'):  # Valid response; got coordinates
                self.update_bounds(get_screen_bounds(screen))
                return True  # Changed successfully

    def update_bounds(self, bounds):
        self.origin_x = bounds[0]
        self.origin_y = bounds[1]
        self.width = bounds[2]
        self.height = bounds[3]
        self.u_height = bounds[3] - self.master_height


class WindowPosition:
    def __init__(self, location, origin, size):
        self.location = location
        self.origin = origin
        self.size = size

    def move_window(self, window):
        # When resized or moved, macOS honors the screen bounds at the current
        # origin and won't resize past bounds. This means that if the window was
        # resized or moved but exceeded the bounds, the window will not have the
        # desired size. To get around this, Resize the window first, relocate
        # (definitely not out of bounds due to first resize), then resize again
        # (initial resize might've hit bounds). Can't use `setBounds_` as it
        # honors the window's minimum bounds.
        window.setVisible_(0)  # Pop tab if in a multi-tab window
        window.setSize_(self.size)
        window.setOrigin_(self.origin)
        window.setSize_(self.size)  # Don't worry; still really quick
        window.setFrontmost_(1)  # Above other windows


def args_init():
    import argparse

    p = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    p.add_argument('command',
                   type=str,
                   help='the command to run on each item. Can include ' +
                   'arguments if quoted')
    p.add_argument('item',
                   type=str,
                   nargs='+',
                   help='one or more items, each passed as a positional ' +
                   'argument to an instance of the command')
    p.add_argument('-k',
                   '--keep',
                   action='store_true',
                   help='keep windows open even after command exits cleanly')
    p.add_argument('-p',
                   '--pause',
                   type=int,
                   metavar='ms',
                   help='milliseconds to wait between each window',
                   default=0)
    p.add_argument('-s',
                   '--screen',
                   type=int,
                   metavar='id',
                   help='screen number to display windows on',
                   default=1)
    p.add_argument('--mw-c',
                   type=str,
                   metavar='r,g,b',
                   help='color of the master window',
                   default=MASTER_COLOR)
    p.add_argument('--mw-h',
                   type=int,
                   metavar='px',
                   help='height of the master window',
                   default=MASTER_HEIGHT_MIN)
    p.add_argument('--sw-c',
                   type=str,
                   metavar='r,g,b',
                   help='color of a slave window',
                   default=SLAVE_COLOR)
    p.add_argument('--sw-c-d',
                   type=str,
                   metavar='r,g,b',
                   help='color of a disabled slave window',
                   default=SLAVE_DISABLED_COLOR)

    # Hidden arguments relating to program internals
    p.add_argument('--mode', type=str, help=argparse.SUPPRESS)
    p.add_argument('--reinit', action='store_true', help=argparse.SUPPRESS)
    p.add_argument('--socket', type=str, help=argparse.SUPPRESS)

    return p.parse_args()


def cprint(string=None):  # Do not over-use; it runs a command to clear screen
    os.system('clear && printf \'\\e[3J\'')
    if string is not None: print(string, end='', flush=True)


def get_base_command(args, title='{}'):
    carried = ['history -d $(($HISTCMD-1));']  # Remove from history
    carried.append('clear && printf \'\\e[3J\';')  # Clear screen
    carried.append('printf \'\\e]0;%s\\a\' \'{}\';'.format(title))  # Set title
    if not args.keep: carried.append('if')  # Close on clean exit
    carried.append(BIN_LOCATION)  # cterm location
    carried += ['--pause', str(args.pause)]
    carried += ['--screen', str(args.screen)]
    carried += ['--mw-h', str(args.mw_h)]
    carried += ['--sw-c', str(args.sw_c)]
    carried += ['--sw-c-d', str(args.sw_c_d)]
    if args.keep: carried.append('--keep')
    carried.append(quote(args.command))  # Escape command to run
    carried.append('{}')  # Used for the items
    if not args.keep: carried.append('; then exit; fi')  # Close on clean exit
    return ' '.join(carried)


def get_columns_default(screen, count, columns=1):
    w, h = screen.width, screen.u_height
    size = get_window_size(screen, count, columns)
    ratio = size[1] / size[0]
    if ratio > h / w: return {columns: ratio}
    ratios = {
        columns: ratio,
        **get_columns_default(screen, count, columns + 1)
    }
    key, value = min(ratios.items(), key=lambda x: abs(x[1] - h / w))
    return key if columns == 1 else {key: value}


def get_color(*args):
    for color in args:
        m = re.match(r'(\d+),(\d+),(\d+)', color)
        if m:
            from ScriptingBridge import NSColor
            return NSColor.colorWithDeviceRed_green_blue_alpha_(
                int(m.group(1)) / 255,
                int(m.group(2)) / 255,
                int(m.group(3)) / 255, 0)


def get_positions(screen, columns, count):
    rows = ceil(count / columns)
    size = get_window_size(screen, count, columns)

    master_window = WindowPosition([], [screen.origin_x, screen.origin_y],
                                   [screen.width, screen.master_height])
    positions = [master_window]  # First window position is the master

    for r in reversed(range(rows)):  # Reversed(bottom to top)
        for c in range(columns):  # Left to right
            position = [
                screen.origin_x + (c * size[0]),
                screen.origin_y + screen.master_height + (r * size[1])
            ]  # The y origin is flipped (0 is bottom, not top
            location = [c, abs(rows - r - 1)]
            positions.append(WindowPosition(location, position, size))

    return positions


def get_screen(screen_number=0, reinit=False):
    if reinit:  # Get uncached screen info using a new Window Server connection
        import subprocess
        command = BIN_LOCATION + ' 0 0 --reinit --screen ' + str(screen_number)
        result = subprocess.run(command, stdout=subprocess.PIPE, shell=True)
        return result.stdout.decode().strip()

    from ScriptingBridge import NSApplication, NSBundle, NSScreen

    # Hide the Python launcher icon
    NSBundle.mainBundle().infoDictionary()['LSBackgroundOnly'] = '1'

    # Connect to the Window Server and run initializing code. Without this, the
    # menu bar of non-main screens is not ignored in visibleFrame()
    NSApplication.sharedApplication()

    screens = NSScreen.screens()
    count = screens.count()
    available = 'Available screens: ' + ', '.join(
        [str(x) for x in range(1, count + 1)])

    # Asking for list of screens or out of bounds
    if screen_number == 0: return available  # Asking for list of screen ID's
    if screen_number > count: return 'Screen does not exist. ' + available

    f = screens.objectAtIndex_(screen_number - 1).visibleFrame()
    return '_' + ','.join([
        str(x) for x in [f.origin.x, f.origin.y, f.size.width, f.size.height]
    ])


def get_screen_bounds(s):
    return [float(x) for x in s[1:].split(',')]  # Get rid of the leading _


def get_terminal():
    from ScriptingBridge import SBApplication
    global TERMINAL
    if TERMINAL is None:
        bundle = 'com.apple.Terminal'
        TERMINAL = SBApplication.applicationWithBundleIdentifier_(bundle)
        if TERMINAL is None: sys.exit('Did not find {}'.format(bundle))
    return TERMINAL


def get_window(window_id):
    res = get_terminal().windows().objectWithID_(window_id)
    return res if res.get() else None


def get_window_id(tty):
    for window in get_terminal().windows():
        if tty == window.tabs().objectAtIndex_(0).tty(): return window.id()


def get_window_size(screen, count, columns):
    return [screen.width / columns, screen.u_height / ceil(count / columns)]


def open_terminal(command):
    return get_terminal().doScript_in_(command, 0)


def prompt(question, default=''):
    current_tc_attr = tc_get()  # Save current
    if Menu.init_tc_attr: tc_set(Menu.init_tc_attr)  # Restore initial
    cprint(str(question) + ': ')

    try:
        return input() or default
    except (KeyboardInterrupt, EOFError):
        return default
    finally:  # Restore previous terminal settings
        tc_set(current_tc_attr)


def socket_connect(location):
    def tap(s):
        import fcntl
        try:
            while True:
                for c in s.recv(1024).decode():
                    fcntl.ioctl(sys.stdin, termios.TIOCSTI, c)
        except Exception:
            pass

    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(location)

    threading.Thread(target=tap, args=(s, )).start()
    return s


def socket_create():
    from tempfile import _get_candidate_names, _get_default_tempdir

    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.bind(_get_default_tempdir() + '/' + next(_get_candidate_names()))
    s.listen()
    return s


def sort_natural_key(s, _r=re.compile(r'(\d+)')):
    return [int(t) if t.isdigit() else t.lower() for t in _r.split(s.item)]


def tc_get():
    return termios.tcgetattr(sys.stdin.fileno())


def tc_raw():
    import tty
    tty.setraw(sys.stdin.fileno())


def tc_set(settings):
    termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, settings)


def main():
    args = args_init()

    if args.reinit:  # Someone requested screen info
        print(get_screen(args.screen))
    elif args.mode is None:  # Spawn master window after some init code
        screen = get_screen(args.screen)
        if not screen.startswith('_'): sys.exit(screen)  # An error message

        command = ' '.join([quote(x) for x in args.item]) + ' --mode master'
        title = MASTER_BASE_TITLE + ' '.join(args.item)

        t = open_terminal(get_base_command(args, title).format(command))
        t.setBackgroundColor_(get_color(args.mw_c, MASTER_COLOR))
        t.setNormalTextColor_(get_color('255,255,255'))
    elif args.mode == 'master':  # Master window: spawns and controls slaves
        Master(args, get_base_command(args))
    elif args.mode == 'slave':  # Slave window: runs command and reads input
        s = socket_connect(args.socket)  # Start mirror keystrokes
        os.system(args.command + ' ' + args.item[0])
        s.close()  # Close socket


if __name__ == '__main__': main()
